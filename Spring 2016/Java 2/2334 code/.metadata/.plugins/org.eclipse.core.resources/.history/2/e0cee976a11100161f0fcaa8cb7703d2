import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map.Entry;

import javax.swing.JOptionPane;

public class ParseFile extends Driver {
	
	/**
	 * This method contains the specific characters that are arrows. It helps
	 * the parser method
	 * @param         Char c    		Contains individual characters.
	 * @return        boolean			Returns true or false
	 */
	
	private final static boolean removeArrow (char c) {
		return c == '<' || c == '>';
	}
	
	private final static boolean removeComma(char c) {
		return c == ',';
	}
	
	/**
	 * This method contains the specific characters that are brackets. It helps
	 * the parser method
	 * @param         Char c    		Contains individual characters.
	 * @return        boolean			Returns true or false
	 */
	private final static boolean removeBracket(char c) {
		return c == '[' || c == ']';
	}
	
	/**
	 * This method contains the specific numbers that are digits. It helps
	 * the parser method
	 * @param         Char c    		Contains individual characters.
	 * @return        boolean			Returns true or false
	 */
	private final static boolean isDigit(char c){
		return c>= '0' && c <= '9';
	}
	
	/**
	 * This method contains the specific characters that are considered spaces or tabs. 
	 * It helps the parser method
	 * @param         Char c    		Contains individual characters.
	 * @return        boolean			Returns true or false
	 */
	private final static boolean whiteSpace(char c) {
	 return	c == ' ' || c == '\t';
	}
	
	/**
	 * This method contains the specific characters that are parentheses. It helps
	 * the parser method
	 * @param         Char c    		Contains individual characters.
	 * @return        boolean			Returns true or false
	 */
	private final static boolean isParentheses(char c) {
		return c == '(' || c == ')';	
	}
	
	/**
	 * This method contains the specific numbers that are digits. It helps
	 * the parser method
	 * @param         Char c    		Contains individual characters.
	 * @return        boolean			Returns true or false
	 */
	private final static boolean isReleaseType(char c) {
		return c == 'T' || c == 'V';
	}
	
	private final static boolean removeCurlyBrace(char c) {
		return c == '{' || c == '}';
	}
	
	private final static boolean removeHastag(char c) {
		return c == '#';
	}
	
	private final static boolean removeQuestionMark(char c) {
		return c == '?';
	}
	private final static boolean removeDashSlashAndPeriods(char c) {
		return c == '-' || c == '.' || c == '/';
	}
	
	private final static boolean letterCheck(char c) {
		return c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z';
	}
	
	
	
	/**
	 * This method is to use a line from a file to create a Movie object. This
	 * method should simultaneously create the Movie object and add it to the
	 * List parameter. It should also check to see if the Media object already
	 * exists in the list before adding it 
	 * 
	 * @param line			The line to be parsed	
	 * @return				The new Movie object being created
	 */
	public static Movie parseMovie(String line) {

		/** String year
		 *  the year of the movie.
		 *  This will be converted to a Integer below.
		 */
		 String year = "";
		 
		 /** String movieName
		  *  the name of the movie
		  */
		 String movieName = "";
		 
		 /** String movieInfo
		  *  contains additional information
		  *  of the movie
		  */
		 String movieInfo = "";
		 
		 /** String releaseInfo
		  *  contains information on how the movie was released
		  */
		 String releaseInfo = "";
		 
		 /** General Idea: treat the line like a character array.
		  * Make use of the string.charAt(int) method, to retrieve
		  * characters from the string. Keep an index variable to track
		  * where in the array you are.*/
		 
		 int index = line.length()-1;
		 
		 // Parse year
		 while (isDigit(line.charAt(index)))
		 {
			 year = line.charAt(index) + year;
			 index--;
		 }
		 
		 // If no year was parsed, remove any question marks
		 if (year.length() == 0) {
			 while (removeQuestionMark(line.charAt(index))) {
				 index--;
			 }
		 }
		 
		 /*Skip whitespace*/
		 while (whiteSpace(line.charAt(index))) 
		 {
			 index--;
			 
			 if (isParentheses(line.charAt(index))) 
			 {
				 index--; // removes first parentheses
				 
				 while (isReleaseType(line.charAt(index))) 
				 {
					 // stores the release info of each movie object
					 releaseInfo = line.charAt(index) + releaseInfo;
					 index--;
					 
					 if (isParentheses(line.charAt(index))) 
					 {
						 index--; // skips the last parentheses
					 } 
				 }
				 
				 // If there are question marks in parentheses, remove the question marks
				 while (removeQuestionMark(line.charAt(index))) {
					index--;
					
					if (isParentheses(line.charAt(index))) {
						index--;
					}
				 }
				 
				 // this while statement will check for additional movie
				 // information
				 while (isDigit(line.charAt(index))) 
				 {
					movieInfo = line.charAt(index) + movieInfo;
					index--;
							
					if (isParentheses(line.charAt(index))) {
						index--;
					}
				 }
			 }
		 }
		 // the remaining index should contain the title:
		 while (index >= 0)
		 {
			 movieName = line.charAt(index) + movieName;
			 index--;	 
		 }
		
//		 Integer yearReleased;
//		 // If the line did not contain a year number, parse yearReleased as 0
//		 if (year.length() == 0) {
//			 yearReleased = new Integer(0);
//		 } else {
//			yearReleased = Integer.parseInt(year);
//		 }
		 
		 Movie newMovie = new Movie(movieName, year, releaseInfo);
		 return newMovie;
	}
	
	
	

	/**
	 * This method will take a line from a file and create a Series object.This
	 * method should simultaneously create the Series object and add it to the
	 * List parameter . It should also check to see if the Media object already
	 * exists in the list before adding it using
	 * "list.contains(new object here);"
	 * 
	 * @param line
	 * @param list
	 * @throws IOException 
	 */
	public static void parseSeries(File file, ArrayList<Media> series, ArrayList<Media> episodes) throws IOException {
		String line = "";
		FileReader fr = new FileReader(file);
		BufferedReader br = new BufferedReader(fr);
				
		while((line = br.readLine()) != null) 
		{
			String releaseYear = "";

			String[] divided = line.split(" ");
			String seriesTest = divided[divided.length - 1];
			//Series creator
			if (seriesTest.contains("-"))
			{
				String title = "";
				String[] tabDivide = divided[divided.length - 1].split("\t");
				String releaseYearRange = tabDivide[tabDivide.length - 1];
				releaseYear = releaseYearRange.substring(0, 4);
				for (int i = 0; i < divided.length - 1; ++i)
				{
					if (divided[i].contains("(") && divided[i].contains(")"))
					{
						break;
					}
					else
					{
						title = title + divided[i] + " ";
					}
				}
				Series newSeries = new Series(title, releaseYear, releaseYearRange);
				System.out.println(newSeries);
				series.add(newSeries);
			}
			
			//Episode creator
			else
			{
				int titleIndex = 0;
				String episodeTitle = "";
				String episodeNumber = "";
				String episodeTitleNumber = "";
				String episodeReleaseYear = "";
				String seriesTitle = "";
				String[] tabDivide = divided[divided.length - 1].split("\t");
				
				for (int i = 0; i < divided.length; ++i)
				{
					if (divided[i].contains("{"))
					{
						titleIndex = i;
						break;
					}
				}
				for (int i = titleIndex; i <divided.length; ++i)
				{
					episodeTitleNumber = episodeTitleNumber + divided[i] + " ";		
				}
				episodeTitleNumber = episodeTitleNumber.replace("{", "");
				episodeTitleNumber = episodeTitleNumber.replace("}", "");
				//System.out.println(episodeTitleNumber);
				
				String[] episodeInfoDivided = episodeTitleNumber.split(" ");
				episodeReleaseYear = tabDivide[tabDivide.length - 1];
				//System.out.println(episodeReleaseYear);
				for (int i = 0; i < episodeInfoDivided.length - 1; ++i)
				{
					if (episodeInfoDivided[i].contains("."))
					{
						break;
					}
					else
					{
						episodeTitle = episodeTitle + episodeInfoDivided[i] + " ";
					}
				}
				for (int i = 0; i < divided.length - 1; ++i)
				{
					if (divided[i].contains("."))
					{
						episodeNumber = divided[i];
					}
				}
				//System.out.println(episodeTitle);		
				
				for (int i = 0; i < divided.length - 1; ++i)
				{
					if (divided[i].contains("(") && divided[i].contains(")"))
					{
						break;
					}
					else
					{
						seriesTitle = seriesTitle + divided[i] + " ";
					}
				}
				seriesTitle.replace("\"", "");
				//System.out.println(seriesTitle);
				
				Episode newEpisode = new Episode(episodeTitle, seriesTitle, episodeNumber, episodeReleaseYear);
				episodes.add(newEpisode);
				System.out.println(newEpisode);
				for (int i = 0; i < series.size(); ++i)
				{
					if (series.get(i).getTitle().contains(seriesTitle))
					{
						Series inputSeries = (Series)series.get(i);
						inputSeries.addEpisode(newEpisode);
					}
				}
			}
		}
		br.close();
	}

	
	
	
	/**
	 * This method will take a line from a file and use it to add acting credits
	 * to a MediaMaker object stored in a LinkedHashMap.
	 * 
	 * 1st: The method will isolate an actor NAME, create a MediaMaker object
	 * which will be stored in the HashMap. The actors name will be the key, The
	 * MediaMaker object will be the value stored.
	 * 
	 * 
	 * **When a MediaMaker object is created it will initialize several empty
	 * ArrayLists of <Series> or <Movies> which can be accessed with the
	 * MediaMaker class' add methods.**
	 * 
	 * 2nd: The method will call parseMovie or parseSeries depending on the
	 * Media Type. Some kind of marker will be used to determine which type
	 * we're dealing with.
	 * 
	 * 3rd: The Movie or Series will be added to the LinkedHashMap. You can
	 * access the object with
	 * The parse
	 * movie method will add any movies to the list of Media objects that arent
	 * already in there so dont worry about doing that here.
	 * 
	 * ***NOTE*** We will have to nest this process in some kind of loop that
	 * repeats it until it comes across a line that has a new actor's name.
	 * 
	 * 
	 * @param fileLine
	 *            A line from the Actors file.
	 * @param people
	 *            A HashMap where the info will be stored.
	 */
	public static MediaMaker parseCredits(String line) {
		//mediaMaker credentials to create keys
		String lastName = "";
		String firstName = "";
		String additionalPersonInfo = "";
		String fullName = "";
		
		
		//This will allow the creation of a MediaMaker object
		// that will be placed into the LinkedHashMap
		String billingOrder = "";
		String role = "";
		String credit = "";
		boolean suspended = false;
		String mediaType = "";
		String additonalMovieRelease = "";
		Integer movieRelease = new Integer(0);
		String year = "";
		String title = "";
		int index = 0;
		String seasonNumber = "";
		String episodeNumber = "";
		String episodeTitle = "";
		String episodeAppearance = "";
		String episodeReleaseYear = "";
		Integer episodeRelease = new Integer(0);
	
		
		//this will keep track of where the first Name ends
		int count = 0;
		//lets check if we are adding someone or if we are looking for someone in the list.
		if (!whiteSpace(line.charAt(count))) {
			//generates Actors last Name
			while(!removeComma(line.charAt(count)));
			lastName = lastName + line.charAt(count);
			++count;
			while (!whiteSpace(line.charAt(count))) 
			{
				//removes comma that seperates name
				if(removeComma(line.charAt(count))) {
					++count;
				}
				firstName = firstName + line.charAt(count);
				++count;

			}
			while(whiteSpace(line.charAt(count)))
			{
				++count;
				if (isParentheses(line.charAt(count)))
				{
					while(letterCheck(line.charAt(count))) 
					{
						additionalPersonInfo = additionalPersonInfo + line.charAt(count);
						++count;
					}
				}
			}
		if (firstName.length() > 0 && lastName.length() > 0) {
			fullName = firstName + " " + lastName;
		}
		else if (firstName.length() > 0 && lastName.length() > 0 && additionalPersonInfo.length() > 0) {
			fullName = firstName + " " + lastName + " (" + additionalPersonInfo + ")";
		}
		
		index = line.length() - 1;
		
		while (whiteSpace(line.charAt(index))) {
			//remove whiteSpace
			--index;
			if(removeArrow(line.charAt(index))){
			--index;
				while(!removeArrow(line.charAt(index))) {
					billingOrder = line.charAt(index) + billingOrder;
					--index;
				}
			}
			//remove last arrow
			--index; 
			
			if(removeBracket(line.charAt(index))) {
				--index;
				while(!removeBracket(line.charAt(index))) {
					role = line.charAt(index) + role;
					--index;
				}
			}
			//remove last bracket
			--index; 
			if(isParentheses(line.charAt(index))) {
				while (!isParentheses(line.charAt(index))) {
					credit = line.charAt(index) + credit;
					--index;
				}
			}
			//remove parentheses
			--index;
			if(removeCurlyBrace(line.charAt(index))) {
				--index;
				if (removeCurlyBrace(line.charAt(index))) {
					--index;
					while(!removeCurlyBrace(line.charAt(index))) 
					{
						//checking to see if its suspended
						suspended = true;
						--index;
						while (removeCurlyBrace(line.charAt(index))) 
						{
							--index;
						}
					
					}
				}
					
			}
			
			if (removeCurlyBrace(line.charAt(index))) {
				--index;
				if(isParentheses(line.charAt(index))) {
					--index;
					if(isDigit(line.charAt(index))) {
						while(isDigit(line.charAt(index))) {
							episodeNumber = line.charAt(index) + episodeNumber;
							--index;
							if(removeDashSlashAndPeriods(line.charAt(index))) {
								--index;
								while(isDigit(line.charAt(index))) {
									seasonNumber = line.charAt(index) + seasonNumber;
									--index;
									if (removeHastag(line.charAt(index))) {
										//not needed
										--index;
										if(isParentheses(line.charAt(index))) {
											--index;
										}
									}
									else if (removeDashSlashAndPeriods(line.charAt(index))) {
										--index;
										while(isDigit(line.charAt(index))) {
											episodeReleaseYear = line.charAt(index) + episodeReleaseYear;
											--index;
											if(isParentheses(line.charAt(index))) {
												--index;
												if (removeCurlyBrace(line.charAt(index))) {
													--index;
												}
											}
										}
									}
								}
							}
						}
						
					}
				}
				while (!removeCurlyBrace(line.charAt(index))) {
					episodeTitle = line.charAt(index) + episodeTitle;
					--index;
					if(removeCurlyBrace(line.charAt(index))) {
						--index;
						if (removeCurlyBrace(line.charAt(index))) {
							--index;
						}
					}
				}
				
			}
			
	
			if(isParentheses(line.charAt(index))) {
				--index;
				while(isReleaseType(line.charAt(index))) {
					mediaType = line.charAt(index) + mediaType;
					--index;
					if(isParentheses(line.charAt(index))) {
						--index;
					}
				}
			}
			
			if(isParentheses(line.charAt(index))) {
				--index;
				if(letterCheck(line.charAt(index))) {
					additonalMovieRelease = line.charAt(index) + additonalMovieRelease;
					--index;
					if(removeDashSlashAndPeriods(line.charAt(index))) {
						--index;
					}
				}
				while(!isParentheses(line.charAt(index))) {
					year = line.charAt(index) + year;
					--index;
				}
			}
			--index;
			
			
			while (index <= count) {
				title = line.charAt(index) + title;
				--index;
			}
			
			if (episodeTitle.length() > 0 && episodeReleaseYear.length() > 0) 
			{
					episodeRelease = Integer.parseInt(episodeReleaseYear);
					Series series = new Series(episodeTitle, episodeRelease, null);
					MediaMaker person = new MediaMaker(fullName);
					person.addCredit(series);
			}
			else if (episodeTitle.length() > 0 && seasonNumber.length() > 0 && episodeNumber.length() > 0) {
				
				episodeRelease = Integer.parseInt(episodeReleaseYear);
				Episode episode = new Episode(episodeTitle, episodeRelease, title, Integer.parseInt(seasonNumber));
				MediaMaker person = new MediaMaker(fullName);
				Series series = new Series(episodeTitle, episodeRelease, null);
				person.addCredit(episode);
				return person;
				}
			
			else if (episodeTitle.length() == 0 && seasonNumber.length() == 0 && episodeNumber.length() == 0) {
					movieRelease = Integer.parseInt(year);
					
					Movie movies = new Movie(title, movieRelease, mediaType);
					
					MediaMaker person = new MediaMaker(fullName);
					person.addCredit(movies);
					return person;
					
			}
			
		}
		
			
		}
		
		//name is already in list
		else if(whiteSpace(line.charAt(index))) {
						
			index = line.length();		
			
		}
				
		return null;
		
	}

}
